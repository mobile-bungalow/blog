[
  {
    "name": "twister",
    "source": "#version 450\n#pragma tweak_shader(version=1.0)\n\n// Original art by tsone. https://www.shadertoy.com/user/tsone\n\n#pragma utility_block(ShaderInputs)\nlayout(set = 0, binding=0) uniform ShaderInputs {\n    float time;       // shader playback time (in seconds)\n    float time_delta; // elapsed time since last frame in secs\n    float frame_rate; // number of frames per second estimates\n    uint frame_index;  // frame count\n    vec4 mouse;       \n    vec4 date;        // [year, month, day, seconds]\n    vec3 resolution;  // viewport resolution in pixels, [w, h, w/h]\n    uint pass_index;   // updated to reflect render pass\n};\n\n#pragma input(color, name=albedo, default=[0.0, 0.0, 1.0, 1.0])\n#pragma input(bool, name=ADDBASE, default=true)\n#pragma input(bool, name=ADDNOISE, default=true)\n#pragma input(bool, name=OLDSKOOL, default=true)\n#pragma input(float, name=RES, min=1.0, default=30.0) \n#pragma input(float, name=STEPSTART, default=0.777, max=0.9, min=0.5)\n#pragma input(float, name=NOISESCALE, default=2.0)\n#pragma input(float, name=STEPS, min=1.0, default=10.0)\n\nlayout(set = 1, binding = 1) uniform CustomInput {\n  int ADDBASE;\n  int ADDNOISE;\n  int OLDSKOOL;\n  float RES;\n  float STEPSTART;\n  float NOISESCALE;\n  float time_scale;\n  float STEPS;\n  vec4  albedo;\n};\n\nlayout(location = 0) out vec4 out_color; \n\n#define PI 3.14159265359\n\nfloat iTime = time * time_scale;\n\n// Based on iq's 'Noise - value noise' shader:\n// https://www.shadertoy.com/view/lsf3WH\nfloat hash(in vec2 p)\n{\n\tfloat h = dot(p, vec2(127.1, 311.7));\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat vnoiseh2(in vec2 p)\n{\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\tfloat a = hash(i + vec2(0.0, 0.0));\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\treturn mix(mix(a, b, u.x),\n\t\t\t   mix(c, d, u.x), u.y);\n}\n\n// Normal calculation separated from height to reduce loop complexity.\n// If both height and normal are needed in same place, then it would make\n// sense to combine the calculations.\n// Noise derivates/normal based on iq's article:\n// https://iquilezles.org/articles/morenoise\n// NOTE: Result is unnormalized.\nvec3 vnoisen2(in vec2 p)\n{\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n\tvec2 dl = 6.0 * f * (1.0 - f);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\tfloat a = hash(i + vec2(0.0, 0.0));\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\treturn vec3(\n\t\tdl.x * mix((b - a), (d - c), u.y),\n\t\tdl.y * mix((c - a), (d - b), u.x),\n\t\t-1.0);\n}\n\nfloat baseh(in vec2 a)\n{\n\tvec2 s = sin(a);\n\tvec2 s2 = s * s;\n\treturn (s2.y * s2.x);\n}\n\n// Height map normal calculation explained:\n// http://http.developer.nvidia.com/GPUGems/gpugems_ch01.html\nvec3 basen(in vec2 a)\n{\n\tvec2 s = sin(a);\n\tvec2 c = cos(a);\n\tvec2 s2 = s * s;\n\treturn normalize(vec3(\n\t\t2.0 * c.x * s.x * s2.y,\n\t\t2.0 * c.y * s.y * s2.x,\n\t\t-1.0));\n}\n\nfloat height(in vec2 a)\n{\n\tfloat h = 0.74;\n\tif (ADDBASE != 0)\n\t{\n\t\th += 0.2 * baseh(a);\n\t}\n\n\tif (ADDNOISE != 0)\n\t\th += 0.06 * vnoiseh2(NOISESCALE * a);\n\treturn h;\n}\n\nvec3 normal(in vec2 a)\n{\n\tvec3 n = vec3(0.0);\n\tif (ADDBASE != 0)\n\t{\n\t\tn += basen(a);\n\t}\n\tif (ADDNOISE != 0)\n\t\tn += 0.25 * vnoisen2(NOISESCALE * a);\n\treturn normalize(n);\n}\nvoid run(out float _a, inout vec2 _p, in vec2 uv)\n{\n\tuv *= 1.333;\n\n\t_a = -PI;\n\n\tfloat dz = -STEPSTART / STEPS;\n\tvec3 v = vec3(uv.x, uv.y * RES * 0.25 * PI, STEPSTART);\n\tif (OLDSKOOL != 0)\n\t{\n\t\tv.y = floor(v.y + 0.5);\n\t}\n\n\tvec2 offs = vec2(RES * (0.5 * PI * (0.8 + 0.2 * cos(time)) * sin(2.0 * time + 0.5 * v.y / RES)),\n\t\t\t\t\t v.y);\n\n\tif (OLDSKOOL != 0)\n\t{\n\t\toffs = floor(offs + 0.5);\n\t}\n\n\tfor (int i = 0; i < int(STEPS); i++)\n\t{\n\t\tv.z += dz;\n\t\tfloat a = atan(v.x, v.z) * RES;\n\t\tif (OLDSKOOL != 0)\n\t\t{\n\t\t\ta = floor(a + 0.5);\n\t\t}\n\t\tvec2 p = offs + vec2(a, 0.0);\n\t\tp *= 4.0 / RES;\n\t\tfloat r = length(v.xz);\n\t\tfloat h = height(p);\n\t\tif (r < h)\n\t\t{\n\t\t\t_a = a / RES;\n\t\t\t_p = p;\n\t\t\tv.x = 1e10;\n\t\t}\n\t}\n}\n\nvoid main()\n{\n\tvec2 uv = 2.0 * gl_FragCoord.xy / resolution.xy - 1.0;\n\tfloat a;\n\tvec2 p;\n\trun(a, p, uv);\n\tvec3 n = normal(p);\n\tvec3 c;\n\ta = -a;\n\tfloat tx = n.x;\n\tn.x = n.x * cos(a) - n.z * sin(a);\n\tn.z = n.z * cos(a) + tx * sin(a);\n\tvec3 l = -normalize(vec3(cos(time), sin(-time), 1.0));\n\tfloat ndotl = max(0.0, dot(n, l));\n\tc = vec3(0.50, 0.35, 0.20) + albedo.xyz +\n\t\t+vec3(0.60, 0.70, 0.80) * ndotl * ndotl;\n\tc *= c * step(a, 0.5 * PI);\n\tout_color = vec4(c, 1.0);\n}"
  },
  {
    "name": "escape the matrix",
    "source": "#version 450\r\n\r\n// Original shader by Kali: https://www.shadertoy.com/user/Kali\r\n// Slightly modified for tweakability.\r\n\r\n#pragma tweak_shader(version=1.0)\r\n\r\n#pragma utility_block(ShaderInputs)\r\nlayout(set=1, binding=0) uniform ShaderInputs {\r\n    float iTime;       \r\n    float iTimeDelta; \r\n    float iFrameRate;\r\n    uint iFrameIndex; \r\n    vec4 iMouse;       \r\n    vec4 iDate;       \r\n    vec3 iResolution;  \r\n    uint iPassIndex;   \r\n};\r\n\r\n#pragma input(color, name=cube_tint, default=[0.8, 0.3, 0.0, 1.0])\r\n#pragma input(color, name=bg_tint, default=[0.341, 0.77, 0.341, 1.0])\r\n#pragma input(int, name=steps, default=80, min=0, max=200)\r\n#pragma input(float, name=time_scale, default=7, min=0.1, max=30)\r\nlayout(binding=0) uniform custom_inputs {\r\n    int steps;\r\n    float time_scale;\r\n    vec4 cube_tint;\r\n    vec4 bg_tint;\r\n};\r\n\r\n\r\nlayout(location = 0) out vec4 out_color; \r\n\r\nfloat det=.001, t;\r\nvec3 adv;\r\n\r\nfloat hash(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\n\r\nmat2 rot(float a)\r\n{\r\n    float s=sin(a), c=cos(a);\r\n    return mat2(c,s,-s,c);\r\n}\r\n\r\nvec3 path(float t)\r\n    {\r\n    vec3 p=vec3(vec2(sin(t*.1),cos(t*.05))*10.,t);\r\n    p.x+=smoothstep(.0,.5,abs(.5-fract(t*.02)))*10.;\r\n    return p;\r\n}\r\n\r\nfloat fractal(vec2 p)\r\n{\r\n    p=abs(5.-mod(p*.2,10.))-5.;\r\n    float ot=1000.;\r\n    for (int i=0; i<7; i++)\r\n    {\r\n        p=abs(p)/clamp(p.x*p.y,.25,2.)-1.;\r\n        if(i>0)ot=min(ot,abs(p.x)+.7*fract(abs(p.y)*.05+t*.05+float(i)*.3));\r\n        \r\n    }\r\n    ot=exp(-10.*ot);\r\n    return ot;\r\n}\r\n\r\nfloat box(vec3 p, vec3 l)\r\n{\r\n    vec3 c=abs(p)-l;\r\n    return length(max(vec3(0.),c))+min(0.,max(c.x,max(c.y,c.z)));\r\n}\r\n\r\nfloat de(vec3 p, inout float boxhit, inout vec3 boxp)\r\n{\r\n    boxhit=0.;\r\n    vec3 p2=p-adv;\r\n    p2.xz*=rot(t*.2);\r\n    p2.xy*=rot(t*.1);\r\n    p2.yz*=rot(t*.15);\r\n    float b=box(p2,vec3(1.));\r\n    p.xy-=path(p.z).xy;\r\n    float s=sign(p.y);\r\n    p.y=-abs(p.y)-3.;\r\n    p.z=mod(p.z,20.)-10.;\r\n    for (int i=0; i<5; i++)\r\n    {\r\n        p=abs(p)-1.;\r\n        p.xz*=rot(radians(s*-45.));\r\n        p.yz*=rot(radians(90.));\r\n    }\r\n    float f=-box(p,vec3(5.,5.,10.));\r\n    float d=min(f,b);\r\n    if (d==b) { boxp=p2; boxhit=1.; };\r\n    return d*.7;\r\n}\r\n\r\n\r\nvec3 march(vec3 from, vec3 dir)\r\n{\r\n    vec2 fragCoord = vec2(gl_FragCoord.x, iResolution.y - gl_FragCoord.y);\r\n    vec3 p,n,g=vec3(0.);\r\n    float d, td=0.;\r\n    float boxhit = 0.0;\r\n    vec3 boxp = vec3(0.); \r\n    for (int i=0; i<steps; i++)\r\n    {\r\n        p=from+td*dir;\r\n        d=de(p, boxhit, boxp)*(1.-hash(fragCoord.xy+t)*.3);\r\n        if (d<det && boxhit<.5) break;\r\n        td+=max(det,abs(d));\r\n        float f=fractal(p.xy)+fractal(p.xz)+fractal(p.yz);\r\n        //boxp*=.5;\r\n        float b=fractal(boxp.xy)+fractal(boxp.xz)+fractal(boxp.yz);\r\n        vec3 colf=vec3(f*f,f,f*f*f);\r\n        vec3 colb=vec3(b+.1,b*b+.05,0.);\r\n        g+=(length(colf)*bg_tint.rgb)/(3.+d*d*2.)*exp(-.0015*td*td)*step(5.,td)/2.*(1.-boxhit);\r\n        g+=(length(colb))*cube_tint.rgb/(10.+d*d*20.)*boxhit*.5;\r\n    }\r\n    return g;\r\n}\r\n\r\nmat3 lookat(vec3 dir, vec3 up) \r\n{\r\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\r\n    return mat3(rt,cross(rt,dir),dir);\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n    vec2 fragCoord = vec2(gl_FragCoord.x, iResolution.y - gl_FragCoord.y);\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    t=iTime*time_scale;\r\n    vec3 from=path(t);\r\n    adv=path(t+6.+sin(t*.1)*3.);\r\n    vec3 dir=normalize(vec3(uv,.7));\r\n    dir=lookat(adv-from,vec3(0.,1.,0.))*dir;\r\n    vec3 col=march(from, dir);\r\n    out_color=vec4(col,1.0);\r\n}\r\n"
  },
  {
    "name": "persistent buffers",
    "source": "#version 450\r\n#pragma tweak_shader(version=\"1.0\")\r\n\r\n// Adapted from the VidVox \"data\" ISF shader.\r\n\r\n#pragma utility_block(ShaderInputs)\r\nlayout(set=0, binding=0) uniform ShaderInputs {\r\n    float time;       // shader playback time (in seconds)\r\n    float time_delta; // elapsed time since last frame in secs\r\n    float frame_rate; // number of frames per second estimates\r\n    uint frame_index;  // frame count\r\n    vec4 mouse;       // xy is last mouse down position,  abs(zw) is current mouse, sign(z) > 0.0 is mouse_down, sign(w) > 0.0 is click_down event\r\n    vec4 date;        // [year, month, day, seconds]\r\n    vec3 resolution;  // viewport resolution in pixels, [w, h, w/h]\r\n    uint pass_index;   // updated to reflect render pass\r\n};\r\n\r\n#pragma input(color, name=data, default = [0.95, 0.35, 0, 1])\r\n#pragma input(int, name=displayMode, default=0, values=[0,1], labels=[\"block\", \"lines\"])\r\nlayout(set = 0, binding = 3) uniform Data {\r\n  vec4 data;\r\n  int displayMode;\r\n};\r\n\r\n#pragma pass(0, persistent, target=\"dataHistory\", height=1)\r\nlayout(set=0, binding=1) uniform sampler default_sampler;\r\nlayout(set=0, binding=2) uniform texture2D dataHistory;\r\n\r\nlayout(location = 0) out vec4 out_color; \r\n\r\nvoid main()\t{\r\n  ivec2 size = textureSize(sampler2D(dataHistory, default_sampler), 0);\r\n  vec2 fsize = vec2(float(size.x), float(size.y));\r\n\tvec2\tloc = gl_FragCoord.xy;\r\n\tvec4\tinputPixelColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n    if (pass_index == 0) {\r\n\t    inputPixelColor = texture(sampler2D(dataHistory, default_sampler), vec2(loc.x - 1.0, 0.0) / fsize);\r\n\t    if (floor(loc.x) == 0.0)\t{\r\n\t    \tinputPixelColor = data;\r\n\t    } \r\n    } else {\r\n\t\t    vec4 val = texture(sampler2D(dataHistory, default_sampler), loc / fsize);\r\n      if (displayMode == 0) {\r\n\t\t  \t  inputPixelColor = val;\r\n      } else if (displayMode == 1)\t{\r\n\t\t\tfloat\ttmp = floor(val.r * resolution.y);\r\n\t\t\tinputPixelColor.a = val.a;\r\n\t\t\tif (abs((resolution.y - loc.y) - tmp) < 5.0)\t{\r\n\t\t\t\tinputPixelColor.r = 1.0;\r\n\t\t\t\tinputPixelColor.a = 1.0;\r\n\t\t\t}\r\n\t\t\ttmp = floor(val.g * resolution.y);\r\n\t\t\tif (abs((resolution.y - loc.y) - tmp) < 5.0)\t{\r\n\t\t\t\tinputPixelColor.g = 1.0;\r\n\t\t\t\tinputPixelColor.a = 1.0;\r\n\t\t\t}\r\n\t\t\ttmp = floor(val.b * resolution.y);\r\n\t\t\tif (abs((resolution.y - loc.y) - tmp) < 5.0)\t{\r\n\t\t\t\tinputPixelColor.b = 1.0;\r\n\t\t\t\tinputPixelColor.a = 1.0;\r\n\t\t\t}\r\n\t\t}\r\n  }\r\n\tout_color = inputPixelColor;\r\n}\r\n\r\n"
  },
  {
    "name": "basic",
    "source": "#version 450\r\n#pragma tweak_shader(version=1.0)\r\n\r\n#pragma utility_block(ShaderInputs)\r\nlayout(set=0, binding=0) uniform ShaderInputs {\r\n    float time;       // shader playback time (in seconds)\r\n    float time_delta; // elapsed time since last frame in secs\r\n    float frame_rate; // number of frames per second estimates\r\n    uint frame_index;  // frame count\r\n    vec4 mouse; \r\n    vec4 date;        // [year, month, day, seconds]\r\n    vec3 resolution;  // viewport resolution in pixels, [w, h, w/h]\r\n    uint pass_index;   // updated to reflect render pass\r\n};\r\n\r\nlayout(location = 0) out vec4 out_color; \r\n\r\n#pragma input(float, name=\"foo\", default=0.0, min=0.0, max=1.0)\r\nlayout(set = 1, binding = 0) uniform Ecco {\r\n    float foo;\r\n};\r\n\r\n\r\nvoid main()\r\n{\r\n    vec2 st = (gl_FragCoord.xy / resolution.xy);\r\n    out_color = vec4(foo, sin(time), st.x, 1.0); \r\n }"
  },
  {
    "name": "plexus",
    "source": "#version 450\r\n#pragma tweak_shader(version=\"1.0\")\r\n\r\n// Credit to enslow: https://www.shadertoy.com/user/enslow\r\n\r\n#pragma utility_block(ShaderInputs)\r\nlayout(set=0, binding=0) uniform ShaderInputs {\r\n    float time;       // shader playback time (in seconds)\r\n    float time_delta; // elapsed time since last frame in secs\r\n    float frame_rate; // number of frames per second estimates\r\n    uint frame_index;  // frame count\r\n    vec4 mouse;       // xy is last mouse down position,  abs(zw) is current mouse, sign(z) > 0.0 is mouse_down, sign(w) > 0.0 is click_down event\r\n    vec4 date;        // [year, month, day, seconds]\r\n    vec3 resolution;  // viewport resolution in pixels, [w, h, w/h]\r\n    uint pass_index;   // updated to reflect render pass\r\n};\r\n\r\n\r\nlayout(location = 0) out vec4 out_color; \r\n\r\n#pragma input(float, name=seed, default=0.1, min=0.0, max=3.0)\r\n#pragma input(float, name=seed2, default=0.1, min=0.0, max=3.0)\r\n#pragma input(float, name=radius, default=0.2, min=0.0)\r\n#pragma input(float, name=speed, default = 1.0, min=0.0)\r\n#pragma input(float, name=max_dist, default = 1.0, min=0.0)\r\n#pragma input(color, name=line_color, default=[0.0, 1.0, 0.0, 1.0])\r\n#pragma input(color, name=point_color, default=[0.0, 1.0, 0.0, 1.0])\r\n#pragma input(point, name=offset, max=[1.0, 1.0], min=[-1.0, -1.0])\r\nlayout(set = 0, binding = 1) uniform CustomInput {\r\n    float seed;       \r\n    float seed2;       \r\n    float radius;       \r\n    float max_dist;       \r\n    float speed;       \r\n    vec4 line_color;       \r\n    vec4 point_color;       \r\n    vec2 offset;\r\n};\r\n\r\n#define num 10\r\n\r\n//Segment function credit: https://www.shadertoy.com/view/MlcGDB\r\n//User: gPlatl\r\n\r\nstruct circle\r\n{\r\n    float r;\r\n\tvec2 p;\r\n};\r\n    \r\nfloat segment(vec2 P, vec2 A, vec2 B, float r) \r\n{\r\n    vec2 g = B - A;\r\n    vec2 h = P - A;\r\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\r\n\treturn smoothstep(r, 0.5*r, d);\r\n}\r\n    \r\n    \r\nfloat hash1(int x)\r\n{\r\n    return sign(sin(float(x)*432.))*fract(sin(float(x)*seed));\r\n}\r\nfloat hash2(int x)\r\n{\r\n    return sign(sin(float(x)*273.))*fract(sin(float(x)*seed2));\r\n}\r\n\r\nvoid main()\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = 5.*(gl_FragCoord.xy-0.5*resolution.xy)/resolution.y;\r\n    \r\n    vec3 col = vec3(0.);    \r\n    float t = time*speed/3.;\r\n    \r\n    \r\n    circle v[num];\r\n    for (int i=0;i<num;i++)\r\n    {\r\n        v[i].r = radius;\r\n        v[i].p = vec2( cos(t+float(i*24)),sin(t+float((i)*32)) ) + vec2(hash1(i),hash2(i)) + vec2(offset.x, -offset.y);\r\n        for (int j=0;j<i;j++)\r\n        {\r\n            float d = distance(v[i].p,v[j].p);\r\n            if (d > max_dist)\r\n            {\r\n                continue;\r\n            }\r\n            float intensity = segment(uv,v[i].p,v[j].p,0.01)*(-exp(d-max_dist)+1.);\r\n            col = col+(line_color.rgb * intensity);\r\n        }\r\n        if (length(v[i].p-uv) < v[i].r)\r\n        {\r\n            col = col+point_color.rgb;\r\n        }\r\n    }\r\n    \r\n    \r\n    // Output to screen\r\n    out_color = vec4(col, length(col));\r\n}\r\n"
  }
]
